<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Í∞ÄÏ°± Ìè¨ÌÜ†Î∂ÄÏä§</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #020617; color: white; touch-action: none; min-height: 100vh; display: flex; flex-direction: column; }
        .shutter-flash { animation: flash 0.4s ease-out; }
        @keyframes flash {
            0% { background: white; opacity: 1; }
            100% { background: transparent; opacity: 0; }
        }
        .effect-card {
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            filter: brightness(0.6);
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
        }
        .effect-card:hover { filter: brightness(1); background-color: #1e293b; }
        .effect-card.active { 
            background-color: #2563eb;
            filter: brightness(1);
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.4);
        }
        canvas { 
            border-radius: 1rem; 
            width: 100%; 
            height: auto; 
            max-height: 72vh;
            object-fit: contain; 
            background: #000;
        }
        .effect-label { 
            font-size: 1rem; 
            font-weight: 800; 
            text-align: center; 
            color: #cbd5e1;
            letter-spacing: -0.025em;
        }
        .active .effect-label { color: #ffffff; }
    </style>
</head>
<body class="p-2 md:p-4">

    <!-- Î©îÏù∏ ÌôîÎ©¥ -->
    <main class="relative w-full max-w-5xl mx-auto flex flex-col items-center">
        <div id="flash-overlay" class="absolute inset-0 z-50 pointer-events-none rounded-xl"></div>
        
        <div id="setup-view" class="absolute inset-0 z-10 flex flex-col items-center justify-center bg-slate-950/90 backdrop-blur-md rounded-xl p-6 text-center">
            <button id="start-btn" class="bg-blue-600 hover:bg-blue-500 px-12 py-4 rounded-full font-bold text-white transition-all active:scale-95">
                Ïπ¥Î©îÎùº ÏãúÏûëÌïòÍ∏∞
            </button>
            <p id="error-log" class="text-red-400 mt-4 text-sm hidden"></p>
        </div>

        <canvas id="gl-canvas"></canvas>
        
        <!-- Ï¥¨ÏòÅ Î≤ÑÌäº -->
        <div class="absolute bottom-6 left-1/2 -translate-x-1/2 z-20">
            <button id="snap-btn" class="bg-white text-slate-900 w-16 h-16 rounded-full shadow-2xl flex items-center justify-center transition-all active:scale-75 disabled:opacity-10" disabled>
                <div class="w-12 h-12 rounded-full border-2 border-slate-900"></div>
            </button>
        </div>
        <div id="countdown" class="hidden text-[12rem] font-black text-white absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 drop-shadow-2xl z-30"></div>
    </main>

    <!-- 20Í∞ÄÏßÄ Ìö®Í≥º Í∑∏Î¶¨Îìú -->
    <section class="w-full max-w-5xl mx-auto mt-6 mb-8">
        <div id="effect-list" class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-5 gap-3">
            <!-- Ìö®Í≥º Î≤ÑÌäºÎì§Ïù¥ Ïó¨Í∏∞Ïóê ÏÉùÏÑ±Îê©ÎãàÎã§ -->
        </div>
    </section>

    <!-- Ìé∏Ïßë ÌôîÎ©¥ -->
    <div id="editor-view" class="fixed inset-0 z-50 bg-slate-950 flex flex-col hidden">
        <!-- ÏÉÅÎã® Î∞î -->
        <header class="flex items-center justify-between p-4 bg-slate-900 border-b border-slate-800">
            <button id="editor-close" class="text-white px-4 py-2 rounded-lg hover:bg-slate-800 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
            </button>
            <h2 class="text-lg font-bold">ÏÇ¨ÏßÑ Ìé∏Ïßë</h2>
            <button id="editor-save" class="bg-blue-600 text-white px-6 py-2 rounded-full font-bold hover:bg-blue-500 transition-colors">
                Ï†ÄÏû•
            </button>
        </header>

        <!-- Ï∫îÎ≤ÑÏä§ ÏòÅÏó≠ -->
        <div class="flex-1 flex items-center justify-center p-4 overflow-hidden bg-black relative">
            <canvas id="editor-canvas" class="max-w-full max-h-full object-contain rounded-lg shadow-2xl"></canvas>
        </div>

        <!-- ÌïòÎã® Ìà¥Î∞î -->
        <div class="bg-slate-900 border-t border-slate-800 pb-safe">
            <!-- Ìà¥ Ìå®ÎÑê -->
            <div id="tool-panels" class="p-4 h-32 overflow-y-auto">

                <!-- ÌïÑÌÑ∞ Ìå®ÎÑê -->
                <div id="panel-filter" class="flex gap-4 overflow-x-auto pb-2">
                    <!-- JSÎ°ú Ï±ÑÏõåÏßê -->
                </div>

                <!-- Ïä§Ìã∞Ïª§ Ìå®ÎÑê -->
                <div id="panel-sticker" class="hidden flex flex-wrap gap-4 justify-center">
                    <!-- JSÎ°ú Ï±ÑÏõåÏßê -->
                </div>

                <!-- Í∑∏Î¶¨Í∏∞ Ìå®ÎÑê -->
                <div id="panel-draw" class="hidden flex flex-col gap-3 items-center">
                    <div class="flex gap-4">
                        <input type="color" id="brush-color" value="#ffffff" class="w-10 h-10 rounded cursor-pointer bg-transparent">
                        <input type="range" id="brush-size" min="1" max="20" value="5" class="w-48">
                    </div>
                    <button id="undo-draw" class="text-sm text-slate-400 hover:text-white flex items-center gap-1">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
                        </svg>
                        ÎêòÎèåÎ¶¨Í∏∞
                    </button>
                </div>
            </div>

            <!-- ÌÉ≠ Î©îÎâ¥ -->
            <div class="flex justify-around items-center border-t border-slate-800">
                <button class="tool-tab flex-1 py-4 text-center font-bold text-slate-400 hover:text-white transition-colors active" data-target="panel-filter">ÌïÑÌÑ∞</button>
                <button class="tool-tab flex-1 py-4 text-center font-bold text-slate-400 hover:text-white transition-colors" data-target="panel-sticker">Ïä§Ìã∞Ïª§</button>
                <button class="tool-tab flex-1 py-4 text-center font-bold text-slate-400 hover:text-white transition-colors" data-target="panel-draw">Í∑∏Î¶¨Í∏∞</button>
            </div>
        </div>
    </div>

    <video id="video" class="hidden" autoplay playsinline muted></video>

    <script>
        const canvas = document.getElementById('gl-canvas');
        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
        const video = document.getElementById('video');
        const effectList = document.getElementById('effect-list');
        const snapBtn = document.getElementById('snap-btn');
        const startBtn = document.getElementById('start-btn');
        const setupView = document.getElementById('setup-view');
        const countdownEl = document.getElementById('countdown');

        // ÏóêÎîîÌÑ∞ Í¥ÄÎ†® ÏöîÏÜå
        const editorView = document.getElementById('editor-view');
        const editorCanvas = document.getElementById('editor-canvas');
        const editorCtx = editorCanvas.getContext('2d');
        const toolTabs = document.querySelectorAll('.tool-tab');
        const toolPanels = document.querySelectorAll('#tool-panels > div');

        let originalImage = null; // ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû•Ïö©
        let currentFilter = 'none';
        let stickers = []; // {x, y, text, size}
        let drawingPaths = []; // [{points: [{x, y}], color, size}]
        let isDrawing = false;
        let activeTool = 'filter'; // filter, sticker, draw

        const vsSource = `
            attribute vec4 aPosition;
            attribute vec2 aTexCoord;
            varying vec2 vTexCoord;
            void main() { gl_Position = aPosition; vTexCoord = aTexCoord; }
        `;

        const fsHeader = `
            precision mediump float;
            varying vec2 vTexCoord;
            uniform sampler2D uSampler;
            uniform float uTime;
            uniform vec2 uResolution;
        `;

        const effects = [
            { id: 'normal', name: 'ÏõêÎ≥∏' },
            { id: 'bulge', name: 'ÎåÄÏôï ÏΩî', fs: `
                void main() {
                    vec2 uv = vTexCoord;
                    vec2 center = vec2(0.5, 0.5);
                    vec2 dist = uv - center;
                    float r = length(dist);
                    if (r < 0.5) uv = center + dist * (1.0 - 0.7 * (1.0 - pow(r/0.5, 2.0)));
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` },
            { id: 'pinch', name: 'ÌôÄÏ≠âÏù¥', fs: `
                void main() {
                    vec2 uv = vTexCoord;
                    vec2 center = vec2(0.5, 0.5);
                    vec2 dist = uv - center;
                    float r = length(dist);
                    if (r < 0.5) uv = center + normalize(dist) * pow(r/0.5, 1.5) * 0.5;
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` },
            { id: 'twirl', name: 'Î±ÖÍ∏ÄÎ±ÖÍ∏Ä', fs: `
                void main() {
                    vec2 uv = vTexCoord;
                    vec2 center = vec2(0.5, 0.5);
                    vec2 dist = uv - center;
                    float r = length(dist);
                    float angle = atan(dist.y, dist.x) + (0.5 - r) * 8.0;
                    if (r < 0.5) uv = center + vec2(cos(angle), sin(angle)) * r;
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` },
            { id: 'quad', name: '4Í∞ú ÏñºÍµ¥', fs: `
                void main() {
                    vec2 uv = mod(vTexCoord * 2.0, 1.0);
                    if (vTexCoord.x > 0.5) uv.x = 1.0 - uv.x;
                    if (vTexCoord.y > 0.5) uv.y = 1.0 - uv.y;
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` },
            { id: 'kaleido', name: 'ÎßåÌôîÍ≤Ω', fs: `
                void main() {
                    vec2 uv = vTexCoord - 0.5;
                    float a = atan(uv.y, uv.x);
                    float r = length(uv);
                    a = mod(a, 3.14159 / 3.0);
                    a = abs(a - 3.14159 / 6.0);
                    uv = vec2(cos(a), sin(a)) * r + 0.5;
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` },
            { id: 'pixel', name: 'Í≤åÏûÑÏÑ∏ÏÉÅ', fs: `
                void main() {
                    vec2 uv = floor(vTexCoord * 40.0) / 40.0;
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` },
            { id: 'thermal', name: 'Ïó¥Í∞êÏßÄÍ∏∞', fs: `
                void main() {
                    vec3 col = texture2D(uSampler, vTexCoord).rgb;
                    float l = dot(col, vec3(0.3, 0.59, 0.11));
                    vec3 res = mix(vec3(0,0,1), vec3(1,1,0), l);
                    res = mix(res, vec3(1,0,0), smoothstep(0.5, 1.0, l));
                    gl_FragColor = vec4(res, 1.0);
                }
            ` },
            { id: 'glitch', name: 'ÏßÄÏßÅÏßÄÏßÅ', fs: `
                void main() {
                    float g = sin(uTime * 30.0) * 0.015;
                    float r = texture2D(uSampler, vTexCoord + vec2(g, 0)).r;
                    float b = texture2D(uSampler, vTexCoord - vec2(g, 0)).b;
                    gl_FragColor = vec4(r, texture2D(uSampler, vTexCoord).g, b, 1.0);
                }
            ` },
            { id: 'sketch', name: 'Í∑∏Î¶ºÏ≤òÎüº', fs: `
                void main() {
                    vec2 off = 1.0 / uResolution;
                    vec3 c = texture2D(uSampler, vTexCoord).rgb;
                    vec3 r = texture2D(uSampler, vTexCoord + vec2(off.x, 0)).rgb;
                    vec3 d = texture2D(uSampler, vTexCoord + vec2(0, off.y)).rgb;
                    float e = distance(c, r) + distance(c, d);
                    gl_FragColor = vec4(mix(c, vec3(0), e * 6.0), 1.0);
                }
            ` },
            { id: 'rainbow', name: 'Î¨¥ÏßÄÍ∞úÏÉâ', fs: `
                void main() {
                    vec3 col = texture2D(uSampler, vTexCoord).rgb;
                    vec3 rainbow = 0.5 + 0.5 * cos(uTime + vTexCoord.xyx + vec3(0,2,4));
                    gl_FragColor = vec4(col * rainbow * 1.5, 1.0);
                }
            ` },
            { id: 'neon', name: 'Î∞òÏßùÎ∞òÏßù', fs: `
                void main() {
                    vec2 off = 1.5 / uResolution;
                    float e = distance(texture2D(uSampler, vTexCoord).rgb, texture2D(uSampler, vTexCoord+off).rgb);
                    gl_FragColor = vec4(mix(vec3(0), vec3(0, 1, 1), step(0.1, e)), 1.0);
                }
            ` },
            { id: 'invert', name: 'Î∞òÎåÄÏÉâÏÉÅ', fs: `
                void main() {
                    gl_FragColor = vec4(1.0 - texture2D(uSampler, vTexCoord).rgb, 1.0);
                }
            ` },
            { id: 'vhs', name: 'ÏòõÎÇ† TV', fs: `
                void main() {
                    vec2 uv = vTexCoord;
                    uv.x += sin(uv.y * 50.0 + uTime * 15.0) * 0.005;
                    vec4 col = texture2D(uSampler, uv);
                    gl_FragColor = vec4(col.rgb - sin(uv.y * 400.0) * 0.1, 1.0);
                }
            ` },
            { id: 'wave', name: 'ÌùêÎ¨ºÌùêÎ¨º', fs: `
                void main() {
                    vec2 uv = vTexCoord;
                    uv.x += sin(uv.y * 20.0 + uTime * 6.0) * 0.04;
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` },
            { id: 'dot', name: 'Ï†êÎ∞ïÏù¥', fs: `
                void main() {
                    vec2 uv = vTexCoord * uResolution / 7.0;
                    float s = sin(uv.x) * sin(uv.y);
                    float l = dot(texture2D(uSampler, vTexCoord).rgb, vec3(0.3, 0.59, 0.11));
                    gl_FragColor = vec4(vec3(step(1.0 - l, s)), 1.0);
                }
            ` },
            { id: 'poster', name: 'Î¨ºÍ∞êÏπ†', fs: `
                void main() {
                    vec3 col = texture2D(uSampler, vTexCoord).rgb;
                    gl_FragColor = vec4(floor(col * 3.0) / 3.0, 1.0);
                }
            ` },
            { id: 'long', name: 'Í∏∏Ï≠âÍ∏∏Ï≠â', fs: `
                void main() {
                    vec2 uv = vTexCoord;
                    uv.y = pow(uv.y, 1.5);
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` },
            { id: 'bighead', name: 'ÎåÄÎëêÌö®Í≥º', fs: `
                void main() {
                    vec2 uv = vTexCoord;
                    vec2 center = vec2(0.5, 0.8);
                    vec2 dist = uv - center;
                    float r = length(dist);
                    if (r < 0.6) uv = center + dist * pow(r/0.6, 0.5);
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` },
            { id: 'melting', name: 'ÎÖπÏïÑÎÇ¥Î¶º', fs: `
                void main() {
                    vec2 uv = vTexCoord;
                    uv.y += sin(uv.x * 25.0 + uTime * 5.0) * 0.03 * (1.0 - uv.y);
                    gl_FragColor = texture2D(uSampler, uv);
                }
            ` }
        ];

        let programs = {};
        let activeEffect = 'normal';

        function createShader(gl, type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(s));
                gl.deleteShader(s);
                return null;
            }
            return s;
        }

        function initShaders() {
            effects.forEach(eff => {
                const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
                const fsSource = fsHeader + (eff.fs || `void main() { gl_FragColor = texture2D(uSampler, vTexCoord); }`);
                const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

                if (!vs || !fs) {
                    console.error(`Failed to compile shader for effect: ${eff.id}`);
                    return;
                }

                const p = gl.createProgram();
                gl.attachShader(p, vs); gl.attachShader(p, fs);
                gl.linkProgram(p);

                if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
                    console.error(`Failed to link program for effect: ${eff.id}`, gl.getProgramInfoLog(p));
                    gl.deleteProgram(p);
                    return;
                }

                programs[eff.id] = {
                    program: p,
                    aPosition: gl.getAttribLocation(p, "aPosition"),
                    aTexCoord: gl.getAttribLocation(p, "aTexCoord"),
                    uTime: gl.getUniformLocation(p, "uTime"),
                    uResolution: gl.getUniformLocation(p, "uResolution")
                };
            });
        }

        const vertices = new Float32Array([-1,-1,0,1, 1,-1,1,1, -1,1,0,0, 1,1,1,0]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        async function startCamera() {
            try {
                const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: 1280, height: 720 } });
                video.srcObject = s;
                video.onloadedmetadata = () => {
                    video.play();
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    setupView.classList.add('hidden');
                    snapBtn.disabled = false;
                    requestAnimationFrame(render);
                };
            } catch (e) {
                document.getElementById('error-log').innerText = "Ïπ¥Î©îÎùº ÏãúÏûë Ïã§Ìå®: Í∂åÌïúÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.";
                document.getElementById('error-log').classList.remove('hidden');
            }
        }

        function render(time) {
            if (video.readyState < 2) return requestAnimationFrame(render);
            gl.viewport(0, 0, canvas.width, canvas.height);

            let progData = programs[activeEffect];
            if (!progData) progData = programs['normal'];
            if (!progData) return requestAnimationFrame(render);

            const { program, aPosition, aTexCoord, uTime, uResolution } = progData;
            gl.useProgram(program);

            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 16, 0);

            gl.enableVertexAttribArray(aTexCoord);
            gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 16, 8);

            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

            if (uTime) gl.uniform1f(uTime, time * 0.001);
            if (uResolution) gl.uniform2f(uResolution, canvas.width, canvas.height);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }

        function buildList() {
            effects.forEach(eff => {
                const card = document.createElement('div');
                card.className = `effect-card bg-slate-800 border-2 border-transparent ${eff.id === activeEffect ? 'active' : ''}`;
                card.innerHTML = `<span class="effect-label">${eff.name}</span>`;
                card.onclick = () => {
                    document.querySelectorAll('.effect-card').forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    activeEffect = eff.id;
                };
                effectList.appendChild(card);
            });
        }

        startBtn.onclick = startCamera;

        // Ï¥¨ÏòÅ Î≤ÑÌäº ÌÅ¥Î¶≠
        snapBtn.onclick = () => {
            let c = 3; countdownEl.innerText = c; countdownEl.classList.remove('hidden'); snapBtn.disabled = true;
            const t = setInterval(() => {
                c--; if (c > 0) countdownEl.innerText = c;
                else {
                    clearInterval(t); countdownEl.classList.add('hidden');
                    document.getElementById('flash-overlay').classList.add('shutter-flash');

                    setTimeout(() => {
                        openEditor();
                        document.getElementById('flash-overlay').classList.remove('shutter-flash');
                        snapBtn.disabled = false;
                    }, 100);
                }
            }, 800);
        };

        // ÏóêÎîîÌÑ∞ Ïó¥Í∏∞
        function openEditor() {
            // WebGL Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞Ïóê ÎßûÏ∂∞ ÏóêÎîîÌÑ∞ Ï∫îÎ≤ÑÏä§ ÏÑ§Ï†ï
            editorCanvas.width = canvas.width;
            editorCanvas.height = canvas.height;

            // ÌòÑÏû¨ WebGL Ï∫îÎ≤ÑÏä§ ÎÇ¥Ïö©ÏùÑ Ïù¥ÎØ∏ÏßÄÎ°ú Ï†ÄÏû•
            originalImage = new Image();
            originalImage.src = canvas.toDataURL();
            originalImage.onload = () => {
                renderEditor();
                editorView.classList.remove('hidden');
            };

            // Ï¥àÍ∏∞Ìôî
            stickers = [];
            drawingPaths = [];
            currentFilter = 'none';
        }

        // ÏóêÎîîÌÑ∞ Îã´Í∏∞
        document.getElementById('editor-close').onclick = () => {
            if(confirm('Ìé∏ÏßëÌïú ÎÇ¥Ïö©Ïù¥ ÏÇ¨ÎùºÏßëÎãàÎã§. ÎÇòÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?')) {
                editorView.classList.add('hidden');
            }
        };

        // ÌÉ≠ Ï†ÑÌôò Î°úÏßÅ
        toolTabs.forEach(tab => {
            tab.onclick = () => {
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                toolTabs.forEach(t => {
                    t.classList.remove('active', 'text-white');
                    t.classList.add('text-slate-400');
                });
                tab.classList.add('active', 'text-white');
                tab.classList.remove('text-slate-400');

                // Ìå®ÎÑê Ï†ÑÌôò
                const targetId = tab.dataset.target;
                toolPanels.forEach(p => {
                    if(p.id === targetId) p.classList.remove('hidden');
                    else p.classList.add('hidden');

                    if (targetId === 'panel-draw') p.classList.add('flex');
                    else p.classList.remove('flex');

                    if (targetId === 'panel-sticker') p.classList.add('flex');
                });

                activeTool = targetId.split('-')[1]; // filter, sticker, draw
            };
        });

        // ÌïÑÌÑ∞ Î™©Î°ù Ï¥àÍ∏∞Ìôî
        const filters = [
            { name: 'ÏõêÎ≥∏', value: 'none' },
            { name: 'ÌùëÎ∞±', value: 'grayscale(100%)' },
            { name: 'ÏÑ∏ÌîºÏïÑ', value: 'sepia(100%)' },
            { name: 'Î∞ùÍ≤å', value: 'brightness(120%)' },
            { name: 'Ïñ¥Îë°Í≤å', value: 'brightness(80%)' },
            { name: 'ÎåÄÎπÑ', value: 'contrast(150%)' },
            { name: 'Ï±ÑÎèÑ', value: 'saturate(200%)' },
            { name: 'ÎπàÌã∞ÏßÄ', value: 'sepia(50%) contrast(120%)' },
            { name: 'Ï∞®Í∞ÄÏõÄ', value: 'hue-rotate(180deg)' }
        ];
        const filterPanel = document.getElementById('panel-filter');
        filters.forEach(f => {
            const btn = document.createElement('button');
            btn.className = "flex-shrink-0 px-4 py-2 bg-slate-800 rounded-full text-sm font-bold hover:bg-slate-700 transition-colors border border-slate-700";
            btn.innerText = f.name;
            btn.onclick = () => {
                currentFilter = f.value;
                document.querySelectorAll('#panel-filter button').forEach(b => b.classList.remove('bg-blue-600', 'text-white'));
                btn.classList.add('bg-blue-600', 'text-white');
                renderEditor();
            };
            if(f.value === 'none') btn.classList.add('bg-blue-600', 'text-white');
            filterPanel.appendChild(btn);
        });

        // Ï†ÄÏû• Î≤ÑÌäº Î°úÏßÅ
        document.getElementById('editor-save').onclick = () => {
            const link = document.createElement('a');
            link.download = `edited-photo-${Date.now()}.png`;
            link.href = editorCanvas.toDataURL();
            link.click();
        };

        // Ïä§Ìã∞Ïª§ Î™©Î°ù Ï¥àÍ∏∞Ìôî
        const emojis = ['üòä', 'üòÇ', 'üòç', 'üòé', 'üò≠', 'üò°', 'üëç', 'üëé', 'üéâ', '‚ù§Ô∏è', '‚≠ê', 'üî•', 'üê∂', 'üê±', 'üê∞', 'üëë', 'üéÄ', 'üéà', 'üéµ', 'üí°'];
        const stickerPanel = document.getElementById('panel-sticker');
        emojis.forEach(emoji => {
            const btn = document.createElement('button');
            btn.className = "text-4xl hover:scale-125 transition-transform p-2";
            btn.innerText = emoji;
            btn.onclick = () => {
                stickers.push({
                    text: emoji,
                    x: editorCanvas.width / 2,
                    y: editorCanvas.height / 2,
                    size: 100
                });
                renderEditor();
            };
            stickerPanel.appendChild(btn);
        });

        // Í∑∏Î¶¨Í∏∞ ÎèÑÍµ¨ ÏÑ§Ï†ï
        const brushColorInput = document.getElementById('brush-color');
        const brushSizeInput = document.getElementById('brush-size');
        const undoDrawBtn = document.getElementById('undo-draw');

        undoDrawBtn.onclick = () => {
            drawingPaths.pop();
            renderEditor();
        };

        // Ï∫îÎ≤ÑÏä§ Ïù¥Î≤§Ìä∏ Ìï∏Îì§ÎßÅ (Í∑∏Î¶¨Í∏∞ Î∞è Ïä§Ìã∞Ïª§ ÎìúÎûòÍ∑∏)
        let isDraggingSticker = false;
        let draggedStickerIndex = -1;
        let lastX = 0, lastY = 0;

        function getCanvasCoordinates(e) {
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function handleStart(e) {
            e.preventDefault();
            const pos = getCanvasCoordinates(e);

            if (activeTool === 'draw') {
                isDrawing = true;
                drawingPaths.push({
                    color: brushColorInput.value,
                    size: parseInt(brushSizeInput.value),
                    points: [{x: pos.x, y: pos.y}]
                });
            } else if (activeTool === 'sticker') {
                // Ïä§Ìã∞Ïª§ ÏÑ†ÌÉù (Ïó≠ÏàúÏúºÎ°ú Í≤ÄÏÉâÌïòÏó¨ Îß® ÏúÑÏóê ÏûàÎäî Ïä§Ìã∞Ïª§ ÏÑ†ÌÉù)
                for (let i = stickers.length - 1; i >= 0; i--) {
                    const s = stickers[i];
                    // Í∞ÑÎã®Ìïú ÌûàÌä∏ Î∞ïÏä§ (Ï§ëÏã¨ Í∏∞Ï§Ä Î∞òÍ≤Ω 50 Ï†ïÎèÑ)
                    const dx = pos.x - s.x;
                    const dy = pos.y - s.y;
                    if (dx*dx + dy*dy < 2500) { // 50*50
                        isDraggingSticker = true;
                        draggedStickerIndex = i;
                        lastX = pos.x;
                        lastY = pos.y;
                        break;
                    }
                }
            }
            renderEditor();
        }

        function handleMove(e) {
            e.preventDefault();
            const pos = getCanvasCoordinates(e);

            if (activeTool === 'draw' && isDrawing) {
                const currentPath = drawingPaths[drawingPaths.length - 1];
                currentPath.points.push({x: pos.x, y: pos.y});
                renderEditor();
            } else if (activeTool === 'sticker' && isDraggingSticker) {
                const s = stickers[draggedStickerIndex];
                s.x += pos.x - lastX;
                s.y += pos.y - lastY;
                lastX = pos.x;
                lastY = pos.y;
                renderEditor();
            }
        }

        function handleEnd(e) {
            e.preventDefault();
            isDrawing = false;
            isDraggingSticker = false;
            draggedStickerIndex = -1;
        }

        editorCanvas.addEventListener('mousedown', handleStart);
        editorCanvas.addEventListener('mousemove', handleMove);
        editorCanvas.addEventListener('mouseup', handleEnd);
        editorCanvas.addEventListener('mouseout', handleEnd);

        editorCanvas.addEventListener('touchstart', handleStart);
        editorCanvas.addEventListener('touchmove', handleMove);
        editorCanvas.addEventListener('touchend', handleEnd);


        // ÏóêÎîîÌÑ∞ Î†åÎçîÎßÅ Î£®ÌîÑ
        function renderEditor() {
            if (!originalImage) return;

            // 1. Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî
            editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);

            // 2. ÌïÑÌÑ∞ Ï†ÅÏö© Î∞è ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞
            editorCtx.filter = currentFilter;
            editorCtx.drawImage(originalImage, 0, 0);
            editorCtx.filter = 'none'; // Ïù¥ÌõÑ Í∑∏Î¶¨Í∏∞Ïóê ÏòÅÌñ• Ïïà Ï£ºÎèÑÎ°ù Ï¥àÍ∏∞Ìôî

            // 3. Ïä§Ìã∞Ïª§ Í∑∏Î¶¨Í∏∞
            editorCtx.textAlign = "center";
            editorCtx.textBaseline = "middle";
            stickers.forEach(s => {
                editorCtx.save();
                editorCtx.translate(s.x, s.y);
                editorCtx.font = `${s.size}px serif`;
                editorCtx.fillText(s.text, 0, 0);
                editorCtx.restore();
            });

            // 4. Í∑∏Î¶¨Í∏∞ Í≤ΩÎ°ú Í∑∏Î¶¨Í∏∞
            editorCtx.lineCap = 'round';
            editorCtx.lineJoin = 'round';
            drawingPaths.forEach(path => {
                editorCtx.beginPath();
                editorCtx.strokeStyle = path.color;
                editorCtx.lineWidth = path.size;
                if (path.points.length > 0) {
                    editorCtx.moveTo(path.points[0].x, path.points[0].y);
                    for (let i = 1; i < path.points.length; i++) {
                        editorCtx.lineTo(path.points[i].x, path.points[i].y);
                    }
                    editorCtx.stroke();
                }
            });
        }

        initShaders();
        buildList();
    </script>
</body>
</html>